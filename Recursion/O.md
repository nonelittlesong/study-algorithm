# 递归复杂度分析

## 1. 递归的时间复杂度

给出一个递归算法，其时间复杂度 O(T) 通常是递归调用的数量 R 和计算的时间复杂度 O(s) 的乘积：

```
O(T) = R * O(s)
```

### 1.1. 示例

在反转字符串问题中，我们需要以相反的顺序打印字符串，解决问题的递归关系可以表示如下：

```
printReverse(str) = printReverse(str[1..n]) + printReverse(str[n])
```

如您所见，该函数将被递归调用 n 次，R = n。在每次递归调用结束时，我们只是打印字符，因此 O(s) = O(1)。

综上，O(T) = n * O(1) = O(n)。

### 1.2. 执行树分析递归调用数量

在分析递归的时间复杂度时，递归调用的数量不一定和 N 成线性关系。

>执行树定义：  
>执行树是一个用于表示递归函数执行的执行流程的树。树中的每个节点都表示递归调用。因此，树中的节点数量对应执行期间的递归调用的数量。

## 2. 递归的空间复杂度

考虑空间消耗的两个部分：

1. 递归相关空间
2. 非递归相关空间

### 2.1. 递归相关空间

为了完成函数调用，系统应该在栈中分配一些空间来保存三个信息：

1. 函数调用的返回地址。一旦函数调用完成，程序应该知道返回的位置，即函数调用之前的点。
2. 传递给函数调用的参数。
3. 函数调用中的局部变量。

### 2.2. 非递归相关空间

- 全局变量（通常在堆中）
- 记忆化技术所导致的空间成本
