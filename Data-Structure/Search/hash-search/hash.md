# 散列表

存储位置 = f(关键字)

构造哈希函数应遵循以下规则：

1. 一致
2. 简单
3. 均匀

## 1. 散列函数的构造方法

### 1.1. 直接定址法

`f(key) = a * key + b`

应用场景：  
需要事先知道关键字的分布情况，适合查找表较小且连续的情况。

### 1.2. 数学分析法

分析我们的关键字，取其中一段，或对其位移，叠加，用作地址。

应用场景：  
关键字位数较大，知道关键字分布情况且关键字的若干位较均匀。

### 1.3. 折叠法

将关键字从左到右分割成位数相等的几部分，然后叠加求和，并按散列表表长，取后几位作为散列地址。

优点：事先不需要知道关键字情况。

应用场景：  
适合关键字位数较多的情况。

### 1.4. 除留余数法

`f(k) = k mod p (p <= m)`，m 是 散列表的长度

p 的取值规则：

- p 不应为 2 的幂，如果 p = 2^n，则 f(k) 就是 k 的 n 个最低位数字。例如：
  12 % 8 = 4，12 的二进制表示为 1100，后三位为 100。
- 若散列表长为 m，则 p 为小于或等于 m 的最大质数。或，不包含小于 20 质因子的合数。

应用场景：  
不知道关键字分布情况。

### 1.5. 乘法散列法

`f(k) =  ⌊ m(kA mod 1) ⌋` (`0 < A < 1，kA mod 1 即 kA - ⌊kA⌋`)

优点：  
对 m 的选择不是特别关键，一般选择它为 2 的某个次幂（m = 2^n）

应用场景：  
不知道关键字分布情况。

### 1.6. 平方取中法

假设关键字是 321，那么他的平方就是 103041，再抽取中间的 3 位就是 030 或 304 用作散列地址。再比如关键字是 1234 那么它的平方就是 1522756 ，抽取中间 3 位就是 227 用作散列地址。

优点：  
灵活，适用范围广。

应用场景：  
不知道关键字分布，而位数又不是很大的情况。

### 1.7. 随机数法

`f(k) = random(k)`

适用场景：  
关键字的长度不等。

## 2. 解决冲突

- 开放地址法
  - 线性探测法 — 辣鸡，容易堆积
  - 二次探测法 — 解决堆积问题
  - 随机探测法
- 再哈希法 — 用别的哈希
- 链地址法
- 公共溢出区法

### 2.1. 开放地址法

#### 2.1.1. 线性探测法

`g(k) = (f(k) + di) mod m`, (di = 1, 2, 3, ..., m - 1)

在解决冲突的时候，会遇到不是同义词，却争夺一个地址的情况，我们称其为堆积。因为堆积使得我们需要不断的处理冲突，插入和查找效率都会大大降低。

#### 2.1.2. 二次探测法

```
线性探测：g(key) = ( f(key) + di ) MOD m, （di = 1, 2, 3, ..., m-1）
二次探测：f(key) = ( f(key) + di ) MOD m, （di = 1^2 , -1^2 , 2^2 , -2^2, ..., q^2, -q^2, q<=m/2）
```

#### 2.1.3. 随机探测法

相同的随机种子，他每次得到的数列是相同的。

### 2.2. 再哈希法

`f,(key) = RH,( key ) (i = 1,2,3,4.....k)`

这里的RH,就是不同的散列函数，你可以把我们之前说过的那些散列函数都用上，每当发生冲突时就换一个散列函数，相信总有一个能够解决冲突的。这种方法能使关键字不产生聚集，但是代价就是增加了计算时间。

### 2.3. 链地址法

将这些同义词存储在一个单链表中，这种表叫做同义词子表，散列表中只存储同义词子表的头指针。

### 2.4. 公共溢出区法

先通过散列函数计算出散列地址后，先于基本表对比，如果不相等再到溢出表去顺序查找。这种解决冲突的方法，对于冲突很少的情况性能还是非常高的。

## 3. 例子

```java
public class HashTable {
    int [] elem; // 散列表存储数据数组
    public int count = 0; // 散列表插入的数据量
    public int size = 12; // 散列表的最大容量
    public final int NULLKEY = Integer.MIN_VALUE; // 散列表的初始值
    // 初始化哈希表
    public HashTable() {
        this.elem = new int[size];
        for (int i = 0; i < size; i++) {
            this.elem[i] = NULLKEY;
        }
    }
    // 散列函数，这里使用除法散列法，又名除留余数法
    // 插入元素
    public void insertHash(int key) {
        if (count == size) {
            return;
        }
        int index = key % size; // 求散列地址
        // 判断是否有冲突
        while (this.elem[index] != NULLKEY) {
            index = (index + 1) % size; // 线性探索法
        }
        this.elem[index] = key; // 插入值
        count++;
    }
    public String searchHash(int key) {
        int index = key % size;
        // 判断求出的散列地址是否为该值
        while (this.elem[index] != key) {
            index = (index+1) % size;
            // 不存在的情况，一种是散列地址的值为初始值，另一种是循环一圈回到原来的位置
            if (this.elem[index] == NULLKEY || index == key % size) {
                return "不存在";
            }
        }
        return "存在，索引为" + index;
    }
}
```

## 4. 性能分析

1. 散列函数是否均匀  
   可以通过设计散列函数减少冲突，但是由于不同的散列函数对一组关键字产生冲突可能性是相同的，因此我们可以不考虑它对平均查找长度的影响。
2. 处理冲突的方法  
   链地址法处理冲突时不会产生任何堆积，因而具有最佳的平均查找性能。
3. 散列表的装填因子 — α = 填入表中的记录数 / 散列表长度  
   散列表的平均查找长度取决于装填因子，而不是取决于记录数。所以说我们需要做的就是选择一个合适的装填因子以便将平均查找长度限定在一个范围之内。
